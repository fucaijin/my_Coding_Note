^（表示行的开头）         $（表示行的结尾）

regex = "(^[a-z]+)([0-9]+)([A-Z]+$)";   ^[a-z]+ 表示：以a到z直接的范围为开头，+是一个或多个，即一个或多个字母 或者多个数字为结尾，就没有了，
regex = "([a-z]+)([0-9]+)([A-Z]+)";

[a-z] 可以用来匹配任意位置上的小写字母: "...a..."
^[a-z] 只能匹配以小写字母为行首的行: "a..."
[a-z]$ 只能匹配以小写字母为行尾的行: "...a"
^[a-z]$ 应该只能匹配只有一个小写字母的行: "a"

python中，re.search(r'<a href="(.*?)" target="_blank" id="">', raw_code) 表示使用正则表达式在raw_code中搜索所有符合<a href="(.*?)" target="_blank" id="">并去除(.*?)内容

或：
	[abc] 只是一个简单的字符类，匹配其中任意一个字符，或区间内字符
	(a|b|c) 是分组，会返回匹配到的项
	例如：(aba|abc|aca|acb) 等同 a(b[ac]|c[ab])
	
System.out.println("abc".matches("[abc]"));//[abc]表示a或b或c.       注意这样写后面要加+或* 表示多个字符，单独这样输出false
System.out.println("abc".matches("[abc]+"));//[abc]表示a,b or c，此时输出true
System.out.println("abab".matches("[abc]+"));//输出true，因为字符串"abab"里的元素[abc]中都有
System.out.println("abc".matches("[ab]+"));//输出false,因为字符串"abc"中有[ab]里没有的元素
System.out.println("abc".matches("(a|b|c)"));//(a|b|c)是或的关系,输出false，因为这样只表示一个字符
System.out.println("abc".matches("(a|b|c){2}"));//(a|b|c)是或的关系,如果是2个字符也输出false
System.out.println("abc".matches("(a|b|c){3}"));//(a|b|c)是或的关系,现在是3个了字符，于是输出了true