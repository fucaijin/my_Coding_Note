^（表示行的开头）         $（表示行的结尾）

regex = "(^[a-z]+)([0-9]+)([A-Z]+$)";   ^[a-z]+ 表示：以a到z直接的范围为开头，+是一个或多个，即一个或多个字母 或者多个数字为结尾，就没有了，
regex = "([a-z]+)([0-9]+)([A-Z]+)";

[a-z] 可以用来匹配任意位置上的小写字母: "...a..." 
^[a-z] 只能匹配以小写字母为行首的行: "a..." 匹配^之后的[a-z]范围之内，即以小写字母开头的
[a-z]$ 只能匹配以小写字母为行尾的行: "...a" 匹配$之前的[a-z]范围之内，即以小写字母结尾的
^[a-z]$ 应该只能匹配只有一个小写字母的行: "a"

python中，re.search(r'<a href="(.*?)" target="_blank" id="">', raw_code) 表示使用正则表达式在raw_code中搜索所有符合<a href="(.*?)" target="_blank" id="">并去除(.*?)内容

或：
	[abc] 只是一个简单的字符类，匹配其中任意一个字符，或区间内字符
	(a|b|c) 是分组，会返回匹配到的项
	例如：(aba|abc|aca|acb) 等同 a(b[ac]|c[ab])
	
System.out.println("abc".matches("[abc]"));//[abc]表示a或b或c.       注意这样写后面要加+或* 表示多个字符，单独这样输出false
System.out.println("abc".matches("[abc]+"));//[abc]表示a,b or c，此时输出true
System.out.println("abab".matches("[abc]+"));//输出true，因为字符串"abab"里的元素[abc]中都有
System.out.println("abc".matches("[ab]+"));//输出false,因为字符串"abc"中有[ab]里没有的元素
System.out.println("abc".matches("(a|b|c)"));//(a|b|c)是或的关系,输出false，因为这样只表示一个字符
System.out.println("abc".matches("(a|b|c){2}"));//(a|b|c)是或的关系,限定长度为2个字符，所以此此时输出false
System.out.println("abc".matches("(a|b|c){3}"));//(a|b|c)是或的关系,现在是3个了字符，于是输出了true

^匹配开头
$匹配结尾
[a-z]匹配范围
[a-z]+一个或多个
(a|b|c)匹配或
(a|b|c){2}匹配或,且限定长度为2

小括号()：匹配小括号内的字符串，可以是一个，也可以是多个，常跟“|”（或）符号搭配使用，是多选结构的
	示例1：string name = "way2014";  regex：(way|zgw)  result：结果是可以匹配出way的，因为是多选结构，小括号是匹配字符串的
	示例2：string text = "123456789";  regex：(0-9)　result：结果是什么都匹配不到的，它只匹配字符串"0-9"而不是匹配数字, [0-9]这个字符组才是匹配0-9的数字
中括号[]：匹配字符组内的字符，比如咱们常用的[0-9a-zA-Z.*?!]等，在[]内的字符都是字符，不是元字符，比如“0-9”、“a-z”这中间的“-”就是连接符号，表示范围的元字符，如果写成[-!?*(]这样的话，就是普通字符
	示例1： string text = "1234567890";  regex：[0-9]  result：结果是可以匹配出字符串text内的任意数字了，像上边的【或符号“|”在字符组内就是一个普通字符】
	示例2：string text = "a|e|s|v";  regex：[a|e|s]  result：结果就是匹配字符a、e、|三个字符，这个跟(a|e|s)有区别的，区别就是(a|e|s)匹配的是a、e、s三个字符的随意一个，三个中的任意一个，这是的|是元字符
大括号{}：匹配次数，匹配在它之前表达式匹配出来的元素出现的次数，{n}出现n次、{n,}匹配最少出现n次、{n,m}匹配最少出现n次，最多出现m次
