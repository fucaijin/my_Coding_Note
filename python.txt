python笔记

命名规范{
	模块名： 
	小写字母，单词之间用_分割 
	ad_stats.py 

	包名： 
	和模块名一样 

	类名： 
	单词首字母大写 
	AdStats 
	ConfigUtil 

	全局变量名（类变量，在java中相当于static变量）： 
	大写字母，单词之间用_分割 
	NUMBER 
	COLOR_WRITE 

	普通变量： 
	小写字母，单词之间用_分割 
	this_is_a_var 

	实例变量： 
	以_开头，其他和普通变量一样 
	_price    
	_instance_var 

	私有实例变量（外部访问会报错）： 
	以__开头（2个下划线），其他和普通变量一样 
	__private_var 

	专有变量： 
	__开头，__结尾，一般为python的自有变量，不要以这种方式命名 
	__doc__ 
	__class__ 

	普通函数： 
	和普通变量一样： 
	get_name() 
	count_number() 
	ad_stat() 

	私有函数（外部访问会报错）： 
	以__开头（2个下划线），其他和普通函数一样 
	__get_name() 
	————————————————————————————————————————————————————————————————————
	文件名 
	全小写,可使用下划线 
	包 
	应该是简短的、小写的名字。如果下划线可以改善可读性可以加入。如mypackage。 
	模块 
	与包的规范同。如mymodule。 
	类 
	总是使用首字母大写单词串。如MyClass。内部类可以使用额外的前导下划线。 

	函数&方法 
	函数名应该为小写，可以用下划线风格单词以增加可读性。如：myfunction，my_example_function。 
	*注意*：混合大小写仅被允许用于这种风格已经占据优势的时候，以便保持向后兼容。 
	函数和方法的参数 
	总使用“self”作为实例方法的第一个参数。总使用“cls”作为类方法的第一个参数。 
	如果一个函数的参数名称和保留的关键字冲突，通常使用一个后缀下划线好于使用缩写或奇怪的拼写。 
	全局变量 
	对于from M import *导入语句，如果想阻止导入模块内的全局变量可以使用旧有的规范，在全局变量上加一个前导的下划线。 
	*注意*:应避免使用全局变量 
	变量 
	变量名全部小写，由下划线连接各个单词。如color = WHITE，this_is_a_variable = 1 
	*注意*： 
	1.不论是类成员变量还是全局变量，均不使用 m 或 g 前缀。 
	2.私有类成员使用单一下划线前缀标识，多定义公开成员，少定义私有成员。 
	3.变量名不应带有类型信息，因为Python是动态类型语言。如 iValue、names_list、dict_obj 等都是不好的命名。 
	常量 
	常量名所有字母大写，由下划线连接各个单词如MAX_OVERFLOW，TOTAL。 
	异常 
	以“Error”作为后缀。 
	缩写 
	命名应当尽量使用全拼写的单词，缩写的情况有如下两种： 
	1.常用的缩写，如XML、ID等，在命名时也应只大写首字母，如XmlParser。 
	2.命名中含有长单词，对某个单词进行缩写。这时应使用约定成俗的缩写方式。 
	例如： 
	function 缩写为 fn 
	text 缩写为 txt 
	object 缩写为 obj 
	count 缩写为 cnt 
	number 缩写为 num，等。 
	前导后缀下划线 
	一个前导下划线：表示非公有。 
	一个后缀下划线：避免关键字冲突。 
	两个前导下划线：当命名一个类属性引起名称冲突时使用。 
	两个前导和后缀下划线：“魔”（有特殊用途）对象或者属性，例如__init__或者__file__。绝对不要创造这样的名字，而只是使用它们。 
	*注意*：关于下划线的使用存在一些争议。 
	Python 用下划线作为变量前缀和后缀指定特殊变量。 

	_xxx      不能用'from module import *'导入 
	__xxx__ 系统定义名字 
	__xxx    类中的私有变量名 

	核心风格：避免用下划线作为变量名的开始。 

	因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避免用下划线作为变量名的开始。一般来讲，变量名_xxx被看作是“私有的”，在模块或类外不可以使用。当变量是私有的时候，用_xxx 来表示变量是很好的习惯。因为变量名__xxx__对Python 来说刑厥夂澹杂谄胀ǖ谋淞坑Φ北苊庹庵置绺瘛?br> 
	"单下划线" 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量； 
	"双下划线" 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。 

	以单下划线开头（_foo）的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用“from xxx import *”而导入；以双下划线开头的（__foo）代表类的私有成员；以双下划线开头和结尾的（__foo__）代表python里特殊方法专用的标识，如 __init__（）代表类的构造函数。 
	特定命名方式 
	主要是指 __xxx__ 形式的系统保留字命名法。项目中也可以使用这种命名，它的意义在于这种形式的变量是只读的，这种形式的类成员函数尽量不要重载。如 
	class Base(object): 
	def __init__(self, id, parent = None): 
	self.__id__ = id 
	self.__parent__ = parent 
	def __message__(self, msgid): 
	# …略 
	其中 __id__、__parent__ 和 __message__ 都采用了系统保留字命名法。 
	附:Google Python命名规范 
	module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name. 
	————————————————————————————————————————————————————————
	from：http://hi.baidu.com/kxw102/blog/item/212e9f3859202fe33b87ce4b.html 
	理解Python命名机制 

	引子 
	我热情地邀请大家猜测下面这段程序的输出： 
	class A(object): 
		   def __init__(self): 
				  self.__private() 
				  self.public() 
		   def __private(self): 
				  print 'A.__private()' 
		   def public(self): 
				  print 'A.public()' 
	class B(A): 
		   def __private(self): 
				  print 'B.__private()' 
		   def public(self): 
				  print 'B.public()' 
	b = B() 

	初探 
	正确的答案是： 
	A.__private() 
	B.public() 
	如果您已经猜对了，那么可以不看我这篇博文了。如果你没有猜对或者心里有所疑问，那我的这篇博文正是为您所准备的。 
	一切由为什么会输出“A.__private()”开始。但要讲清楚为什么，我们就有必要了解一下Python的命名机制。 
	据 Python manual，变量名（标识符）是Python的一种原子元素。当变量名被绑定到一个对象的时候，变量名就指代这个对象，就像人类社会一样，不是吗？当变 量名出现在代码块中，那它就是本地变量；当变量名出现在模块中，它就是全局变量。模块相信大家都有很好的理解，但代码块可能让人费解些。在这里解释一下： 
	代码块就是可作为可执行单元的一段Python程序文本；模块、函数体和类定义都是代码块。不仅如此，每一个交互脚本命令也是一个代码块；一个脚本文件也是一个代码块；一个命令行脚本也是一个代码块。 
	接 下来谈谈变量的可见性，我们引入一个范围的概念。范围就是变量名在代码块的可见性。如果一个代码块里定义本地变量，那范围就包括这个代码块。如果变量定义 在一个功能代码块里，那范围就扩展到这个功能块里的任一代码块，除非其中定义了同名的另一变量。但定义在类中的变量的范围被限定在类代码块，而不会扩展到 方法代码块中。 

	迷踪 
	据上节的理论，我们可以把代码分为三个代码块：类A的定义、类B的定义和变量b的定义。根据类定义，我们知道代码给类A定义了三个成员变量（Python的函数也是对象，所以成员方法称为成员变量也行得通。）；类B定义了两个成员变量。这可以通过以下代码验证： 
	>>> print '\n'.join(dir(A)) 
	_A__private 
	__init__ 
	public 
	>>> print '\n'.join(dir(B)) 
	_A__private 
	_B__private 
	__init__ 
	public 
	咦，为什么类A有个名为_A__private的 Attribute 呢？而且__private消失了！这就要谈谈Python的私有变量轧压了。 

	探究 
	懂 Python的朋友都知道Python把以两个或以上下划线字符开头且没有以两个或以上下划线结尾的变量当作私有变量。私有变量会在代码生成之前被转换为 长格式（变为公有）。转换机制是这样的：在变量前端插入类名，再在前端加入一个下划线字符。这就是所谓的私有变量轧压（Private name mangling）。如类A里的__private标识符将被转换为_A__private，这就是上一节出现_A__private和 __private消失的原因了。 
	再讲两点题外话： 
	一是因为轧压会使标识符变长，当超过255的时候，Python会切断，要注意因此引起的命名冲突。 
	二是当类名全部以下划线命名的时候，Python就不再执行轧压。如： 
	>>> class ____(object): 
		   def __init__(self): 
				  self.__method() 
		   def __method(self): 
				  print '____.__method()' 
	>>> print '\n'.join(dir(____)) 
	__class__ 
	__delattr__ 
	__dict__ 
	__doc__ 
	__getattribute__ 
	__hash__ 
	__init__ 
	__method              # 没被轧压 
	__module__ 
	__new__ 
	__reduce__ 
	__reduce_ex__ 
	__repr__ 
	__setattr__ 
	__str__ 
	__weakref__ 
	>>> obj = ____() 
	____.__method() 
	>>> obj.__method()      # 可以外部调用 
	____.__method() 
	现在我们回过头来看看为什么会输出“A.__private()”吧！ 

	真相 
	相信现在聪明的读者已经猜到答案了吧？如果你还没有想到，我给你个提示：真相跟C语言里的宏预处理差不多。 
	因为类A定义了一个私有成员函数（变量），所以在代码生成之前先执行私有变量轧压（注意到上一节标红的那行字没有？）。轧压之后，类A的代码就变成这样了： 
	class A(object): 
		   def __init__(self): 
				  self._A__private()          # 这行变了 
				  self.public() 
		   def _A__private(self):           # 这行也变了 
				  print 'A.__private()' 
		   def public(self): 
				  print 'A.public()' 
	是不是有点像C语言里的宏展开啊？ 
	因为在类B定义的时候没有覆盖__init__方法，所以调用的仍然是A.__init__，即执行了self._A__private()，自然输出“A.__private()”了。 
	下面的两段代码可以增加说服力，增进理解： 
	>>> class C(A): 
		   def __init__(self):          # 重写__init__，不再调用self._A__private 
				  self.__private()       # 这里绑定的是_C_private 
				  self.public() 
		   def __private(self): 
				  print 'C.__private()' 
		   def public(self): 
				  print 'C.public()' 
	>>> c = C() 
	C.__private() 
	C.public() 
	############################ 
	>>> class A(object): 
		   def __init__(self): 
				  self._A__private()   # 调用一个没有定义的函数，Python会把它给我的 ^_^～ 
				  self.public() 
		   def __private(self): 
				  print 'A.__private()' 
		   def public(self): 
				  print 'A.public()' 
	>>>a = A() 
	A.__private() 
	A.public() 
	
	
	
	命名约定

	所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的.
	用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含).
	用双下划线(__)开头的实例变量或方法表示类内私有.
	将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.
	对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.
	
	Python之父Guido推荐的规范：
	Type						Public				Internal
	Modules						lower_with_under	_lower_with_under
	Packages					lower_with_under	 
	Classes						CapWords			_CapWords
	Exceptions					CapWords	 
	Functions					lower_with_under()	_lower_with_under()
	Global/Class Constants		CAPS_WITH_UNDER		_CAPS_WITH_UNDER
	Global/Class Variables		lower_with_under	_lower_with_under
	Instance Variables			lower_with_under	_lower_with_under (protected) or __lower_with_under (private)
	Method Names				lower_with_under()	_lower_with_under() (protected) or __lower_with_under() (private)
	Function/Method Parameters	lower_with_under	 
	Local Variables				lower_with_under	 
}

pyqt5{
	测试安装是否成功。写下面的代码，运行看运行是否正确{
		if __name__ == '__main__':  
		app = QtWidgets.QApplication(sys.argv)
		MainWindow = QtWidgets.QMainWindow()
		ui = Ui_MainWindow()

		ui.setupUi(MainWindow) 
		MainWindow.show()
		sys.exit(app.exec_())
	}
	
	生成的ui文件转成py文件以后，在此py文件后面加下面代码即可运行{
		if __name__ == '__main__':  
		app = QtWidgets.QApplication(sys.argv)
		MainWindow = QtWidgets.QMainWindow()
		ui = Ui_MainWindow()

		ui.setupUi(MainWindow) 
		MainWindow.show()
		sys.exit(app.exec_()) 
	}
}

打开pip{
	pip在安装目录的Script文件夹下，在此文件夹打开命令行即可。如果安装了多个Python版本，
	没有配置在环境变量的那个python要打开pip需要使用命令(例如我装了27版本的)：python27 -m pip 这里可以写命令。
	否则会报错：failed to create process.有此错误的方法都可以用这方式解决
	
	列出已经安装的模块使用：pip list
	要删除则使用pip uninstall 模块名
	
	查看pip/第三方库的版本： pip show pip(/scrapy/django)
	更新/升级 pip/第三方库 : easy_install --upgrade pip(或者库名称)
	fucaijin使用的升级代码： pip install -U scrapy(库的名称)
	
	查看Django版本
	检查是否安装成功，可以在dos下查看Django版本。
	1.输入python 
	2.输入import django
	3.输入django.get_version()
	
	在python命令行输入以下命令：
	>>>import django
	>>>django.VERSION
	(1,11,4,'final',0)
	>>>
	(1,11,4,'final',0)是我的版本，就是1.11.4版本

	查看flask版本
	检查是否安装成功，可以在dos下查看flask版本。
	1.输入python 
	2.输入import flask
	3.输入flask.__version__
}

pip安装太慢/被墙/不稳定{
	解决pip安装时速度慢的问题

	国内源：
	新版ubuntu要求使用https源，要注意。

	清华：https://pypi.tuna.tsinghua.edu.cn/simple

	阿里云：http://mirrors.aliyun.com/pypi/simple/

	中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/

	华中理工大学：http://pypi.hustunique.com/

	山东理工大学：http://pypi.sdutlinux.org/

	豆瓣：http://pypi.douban.com/simple/

	临时使用：
	可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple

	例如：pip install django -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。

	永久修改，一劳永逸：
	Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)

	内容如下：

	[global] 
	index-url = https://pypi.tuna.tsinghua.edu.cn/simple 
	[install] 
	trusted-host=mirrors.aliyun.com
	
	windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini。内容同上。
}

导包{
	from SignUp import models
	from 包名 import 文件名
	使用的时候直接models.方法名即可
	例如models.initData()
	
	from weixin.views import login, register
	导入Weixin包中的views文件中的login, register方法
}

Django{
	新建/引入APP{
		在terminal执行： python manage.py startapp startapp weixin(app名称)
		打开项目同名文件夹下的setting.py，在INSTALLED_APPS = []尾部添加项目名称即可
	}
	
	测试服务器的开启：python manage.py runserver
	
	1.创建APP: 	
		在pycharm下方的terminal终端中输入命令：python manage.py startapp cmdb(app名称)
	2.编写路由：
		路由都在urls文件里，它将浏览器输入的url映射到相应的业务处理逻辑。
		打开urls.py文件，在数组里写urlpatterns = [url(r'^index/', views.index),  # 表示以index开头的，第二个参数就是路由，表示views.index这个方法为响应函数
												]
	3.编写业务处理逻辑(业务处理逻辑都在views.py文件里):
		定义def index(request): return 结果
	4.
		
		
		
	创建数据库表:	python manage.py makemigrations
	更新数据库	：	python manage.py migrate
	
	django 返回json格式数据{
		方法1：
			import json
			from django.http import HttpResponse
			def get_an_apple(request):
				resp = {'errorcode': 100, 'detail': 'Get success'}
				return HttpResponse(json.dumps(resp), content_type="application/json")
				
		方法2(推荐)：
		model.py
		class Click(models.Model):
			count = models.IntegerField()
			time = models.CharField(max_length=64, default="")
			
		views.py
		def json1(request):   
			all = Click.objects.values()
			return JSONResponse({"res":"success", "msg":all})
			
		结果：
		{"res":"success", 
		 "msg":[
				{"count":1,"id":1,"time":"2015-12-12"},
				{"count":2,"id":2,"time":"2015-12-2"},
				{"count":3,"id":3,"time":"2015-12-3"}
			   ]
		}
		
	}
	
	
	django settings.py 最佳配置文件，以及各个配置详解{
		# encoding=utf-8
		import os
		import socket

		SITE_ID = 1

		# 项目的根目录
		# 简化后面的操作
		PROJECT_ROOT = os.path.dirname(os.path.dirname(__file__))

		# 加载应用
		# 把应用添加到INSTALLED_APPS中
		from apps.kuser.mysetting import myapp as kuser_app
		from apps.blog.mysetting import myapp as blog_app
		MY_APPS = blog_app + kuser_app

		# 加载静态文件
		from apps.blog.mysetting import my_staticfiles as blog_staticfiles
		from apps.kuser.mysetting import my_staticfiles as kuser_staticfiles
		MY_STATIC_DIRS = blog_staticfiles + kuser_staticfiles

		# 加载模板文件
		from apps.blog.mysetting import my_templates as blog_templates
		from apps.kuser.mysetting import my_templates as kuser_templates
		MY_TEMPLATE_DIRS = blog_templates + kuser_templates

		# 密钥配置
		# 适用于开发环境和部署环境
		# 可以从系统环境中，配置文件中，和硬编码的配置中得到密钥
		try:
			SECRET_KEY = os.environ['SECRET_KEY']
		except:
			try:
				with open(os.path.join(PROJECT_ROOT, 'db/secret_key').replace('\\', '/')) as f:
					SECRET_KEY = f.read().strip()
			except:
				SECRET_KEY = '*lk^6@0l0(iulgar$j)faff&^(^u+qk3j73d18@&+ur^xuTxY'

		# 得到主机名
		def hostname():
			sys = os.name
			if sys == 'nt':
				hostname = os.getenv('computername')
				return hostname

			elif sys == 'posix':
				host = os.popen('echo $HOSTNAME')
				try:
					hostname = host.read()
					return hostname
				finally:
					host.close()
			else:
				raise RuntimeError('Unkwon hostname')

		#调试和模板调试配置
		#主机名相同则为开发环境，不同则为部署环境
		#ALLOWED_HOSTS只在调试环境中才能为空
		if socket.gethostname().lower() == hostname().lower():
			DEBUG = TEMPLATE_DEBUG = True
			ALLOWED_HOSTS = []
		else:
			ALLOWED_HOSTS = [
				'baidu.com',
				'0.0.0.0',
			]
			DEBUG = TEMPLATE_DEBUG = False


		#数据库配置
		MYDB = {
			'mysql': {
				'ENGINE': 'django.db.backends.mysql',
				'NAME': 'books',  #你的数据库名称
				'USER': 'root',  #你的数据库用户名
				'PASSWORD': '',  #你的数据库密码
				'HOST': '',  #你的数据库主机，留空默认为localhost
				'PORT': '3306',  #你的数据库端口
			},
			'sqlite': {
				'ENGINE': 'django.db.backends.sqlite3',
				'NAME': os.path.join(PROJECT_ROOT, 'db/db.sqlite3').replace('\\', '/'),
			}
		}

		# 给静态文件url一个后缀，在templates里用到的。
		# 映射到静态文件的url
		#  STATIC_URL的含义与MEDIA_URL类似
		STATIC_URL = '/static/'

		# 总的static目录
		# 可以使用命令 manage.py collectstatic 自动收集static文件
		# STATIC_ROOT = os.path.join(PROJECT_ROOT, 'static').replace('\\', '/')

		#放各个app的static目录及公共的static目录
		#STATICFILES_DIRS：和TEMPLATE_DIRS的含义差不多，就是除了各个app的static目录以外还需要管理的静态文件设置，
		#比如项目的公共文件差不多。然后给静态文件变量赋值，告诉Django，静态文件在哪里
		#另外，Django提供了一个findstatic命令来查找指定的静态文件所在的目录，例如：D:\TestDjango>python manage.py findstatic Chrome.jpg
		# 默认情况下（如果没有修改STATICFILES_FINDERS的话），Django首先会在STATICFILES_DIRS配置的文件夹中寻找静态文件，然后再从每个app的static子目录下查找，
		# 并且返回找到的第一个文件。所以我们可以将全局的静态文件放在STATICFILES_DIRS配置的目录中，将app独有的静态文件放在app的static子目录中。
		# 存放的时候按类别存放在static目录的子目录下，如图片都放在images文件夹中，所有的CSS都放在css文件夹中，所有的js文件都放在js文件夹中。
		STATICFILES_DIRS = (
			("downloads", os.path.join(PROJECT_ROOT, 'static/downloads').replace('\\', '/')),
			("uploads", os.path.join(PROJECT_ROOT, 'static/uploads').replace('\\', '/')),
		)
		# 将app中的静态文件添加到静态文件配置列表中
		STATICFILES_DIRS += MY_STATIC_DIRS


		# 最后关键的部分是STATICFILES_DIRS以下配置
		# 简要说一下，static文件夹在项目里，有css js images 三个文件夹（看项目结构），他们的路径分别是：
		# os.path.join(STATIC_ROOT,'css')，os.path.join(STATIC_ROOT,'js')，os.path.join(STATIC_ROOT,'images')；
		# 我们分别给他们起三个别名css，js，images（你可以随意给，不过为了易记，我们原名称指定别名了）
		TEMPLATE_DIRS = (
			os.path.join(PROJECT_ROOT, 'templates').replace('\\', '/'),
		)
		# 配置应用的模板文件路径
		TEMPLATE_DIRS += MY_TEMPLATE_DIRS

		# 配置缓存
		 CACHES = {
			 'default': {
				 'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
				 'LOCATION': 'unix:/tmp/memcached.sock',
				 'KEY_PREFIX': 'lcfcn',
				 'TIMEOUT': None
			 }
		 }

		LOGIN_REDIRECT_URL = '/'
		LOGIN_URL = '/auth/login/'
		LOGOUT_URL = '/auth/logout/'


		# 指用户上传的文件，比如在Model里面的FileFIeld，ImageField上传的文件。如果你定义
		# MEDIA_ROOT=c:\temp\media，那么File=models.FileField(upload_to="abc/")，上传的文件就会被保存到c:\temp\media\abc。MEDIA_ROOT必须是本地路径的绝对路径。
		MEDIA_ROOT = os.path.join(PROJECT_ROOT, 'static/uploads')

		# MEDIA_URL是指从浏览器访问时的地址前缀。
		MEDIA_URL = '/uploads/'

		# 应用注册列表
		INSTALLED_APPS = (
			'django.contrib.admin',
			'django.contrib.auth',
			'django.contrib.contenttypes',
			'django.contrib.sessions',
			'django.contrib.messages',
			'django.contrib.staticfiles',
			'django.contrib.sites',
			'django.contrib.sitemaps',
		)

		#为了不和系统应用混合，自己开发的应用放在这里
		# 将自己写的app添加到应用列表中去
		INSTALLED_APPS += MY_APPS



		# django 中间件
		# django处理一个Request的过程是首先通过django 中间件，然后再通过默认的URL方式进行的。
		# 所以说我们要做的就是在django 中间件这个地方把所有Request拦截住，
		# 用我们自己的方式完成处理以后直接返回Response,那么我们可以简化原来的设计思路，
		# 把中间件不能处理的 Request统统不管，丢给Django去处理。
		MIDDLEWARE_CLASSES = (
			'django.middleware.cache.UpdateCacheMiddleware',
			'django.contrib.sessions.middleware.SessionMiddleware',
			'django.middleware.common.CommonMiddleware',
			'django.middleware.csrf.CsrfViewMiddleware',
			'django.contrib.auth.middleware.AuthenticationMiddleware',
			# 'django.contrib.auth.middleware.SessionAuthenticationMiddleware',
			'django.contrib.messages.middleware.MessageMiddleware',
			'django.middleware.clickjacking.XFrameOptionsMiddleware',
			'django.middleware.cache.FetchFromCacheMiddleware',
		)

		ROOT_URLCONF = 'lcforum.urls'

		WSGI_APPLICATION = 'lcforum.wsgi.application'

		#数据库配置
		DATABASES = {
			'default': MYDB.get('sqlite'),
		}

		# 语言
		LANGUAGE_CODE = 'zh-cn'

		# 时区
		TIME_ZONE = 'Asia/Shanghai'

		USE_TZ = True




		# 在template中使用静态文件
		# 采用这种方式需要有一些额外配置，打开settings.py，确认TEMPLATE_CONTEXT_PROCESSORS中包含有'django.core.context_processors.static'
		# TEMPLATE_CONTEXT_PROCESSORS = (
		#     'django.core.context_processors.debug',
		#     'django.core.context_processors.i18n',
		#     'django.core.context_processors.media',
		#     'django.core.context_processors.static',
		#     'django.contrib.auth.context_processors.auth',
		#     'django.contrib.messages.context_processors.messages',
		#
		#     'django.core.context_processors.tz',
		#     'django.contrib.messages.context_processors.messages',
		#    # 'blog.context_processors.custom_proc',自定义函数
		# )
		#from django.conf import settings
		#gettext = lambda s: s
		#getattr()

		# 假设有个工程djangodemo，有两个app为demo1跟demo2
		# django处理static的方法是把各个app各自的static合并到一处
		# 比如:
		# djangodemo/djangodemo/static 放置公共静态文件
		# djangodemo/demo1/static 放置该app自己的静态文件
		# djangodemo/demo2/static 放置该app自己的静态文件
		# 可以这么设置：
		# STATIC_ROOT = '/www/djangodemo/djangodemo/static '
		# STATIC_URL = '/static/'
		# STATICFILES_DIRS = (
		#     'djangodemo/static',
		#     'demo1/static/',
		#     'demo2/static/',
		# )
		# 使用命令
		# manage.py collectstatic
		# 就会自动把所有静态文件全部复制到STATIC_ROOT中
		# 如果开启了admin，这一步是很必要的，不然部署到生产环境的时候会找不到样式文件
		# 不要把你项目的静态文件放到这个目录。这个目录只有在运行manage.py collectstatic时才会用到

	}
	
	bug{
		数据库结构更新无效{
			更改model之后，使用以下两个命令行更新数据库的表结构无效：
			python3 manage.py makemigrations
			python3 manage.py migrate
			
			1. 把数据库文件删除
			2. 删除app(你自己创建的app叫什么，此处的app就是什么)底下的migrations文件夹底下的0001..或0002之类为开头的文件(即migrations文件夹下，除了__init__.py文件之外的都要删除)
			3. 在控制台执行命令：
				python manage.py makemigrations
				python manage.py migrate
			4. 打开数据库查看是否更新成功
		}
		
	}
	
	完整Nginx+uWSGI+Django方法部署Django{
		在这种方式中，我们的通常做法是，将nginx作为服务器最前端，它将接收WEB的所有请求，统一管理请求。
		nginx把所有静态请求自己来处理（这是NGINX的强项）。
		然后，NGINX将所有非静态请求通过uwsgi传递给Django，由Django来进行处理，从而完成一次WEB请求。
		nginx具备优秀的静态内容处理能力，然后将动态内容转发给uWSGI服务器，这样可以达到很好的客户端响应。
		nginx可以更加好的做到负载均衡。
		
		安装：
		sudo pip install uwsgi
		sudo apt-get install nginx
		
		一、使用uwsgi+django实现初步访问
		1.安装uwsgi(所有非静态请求通过uwsgi传递给Django，uwsgi相当于一个桥梁的作用) ： pip install uwsgi
		2.写一个test.py{
			def application(env, start_response):
			start_response('200 OK', [('Content-Type','text/html')])
			# return "Hello World" #python2.x用此版本
			return [b"Hello World"] #python3.x用此版本
		}
		3.在控制台进入test.py目录，运行(因为我的云服务器在配置的时候只对公网开放少数的端口，例如80端口，所以此处得填80，通过浏览器才能连上)：(可能需要sudo) uwsgi --http :80 --wsgi-file test.py
		4.访问网页：http://127.0.0.1:8001/(此处的127.0.0.1:8001是你的服务器的公网ip，端口是第3步填的端口，如果是80端口此步骤可以不用写)，如果网页显示了hello world则表示测试成功
		5.(可能需要sudo) uwsgi --http :80  --chdir /home/nocmt/ -w nocmt.wsgi        (uwsgi --http :80(此处是公网开放的端口)  --chdir /home/nocmt/(/home/nocmt/ → 此处是Django的项目目录，我写的是/home/ubuntu/Weixin_fucaijin_django.wsgi) -w nocmt.wsgi(此处是项目名称.wsgi，我写的是Weixin_fucaijin_django.wsgi))
			我的是：(可能需要sudo) uwsgi --http :80  --chdir /home/ubuntu/Weixin_fucaijin_django.wsgi/ -w Weixin_fucaijin_django.wsgi
		
		二、Nginx+uWSGI+Django
		1.配置uwsgi{
			1.创建文件uwsgi.ini
			2.在uwsgi.ini添加{
				[uwsgi]
				chdir = /home/feixue/python/www/for_test 
				module = for_test.wsgi:application 
				socket = 127.0.0.1:8000 
				master = true         
				daemonize = /home/feixue/pyth/for_test/run.log
				disable-logging = true
				
				chdir 是你的博客项目的根目录，我这里的项目名叫for_test；你要替换成你自己的路径；
				moudule 是你的入口wsgi模块，将for_test替换成你自己的项目名称；
				socket 是通信端口设置，这个设置不用改，复制即可；
				master = true 表示以主进程模式运行，不用改，复制即可；
				daemonize 是你的日志文件目录，这个路径就是刚刚新建的run.log文件的路径；
				disable-logging = true 表示不记录正常信息，只记录错误信息，否则你的日志可能很快就爆满了！
				
				我的项目是{
					[uwsgi]
					socket = 127.0.0.1:8000
					chdir=/home/ubuntu/Weixin_fucaijin_django #这是django项目的目录
					module=Weixin_fucaijin_django.wsgi		  #这是django项目名称.wsgi
					master = true         
					processes=4
					threads=2
					max-requests=2000
					chmod-socket=664
					vacuum=true
					daemonize = /home/ubuntu/Weixin_fucaijin_django/uwsgi.log #这是日志目录
					disable-logging = true
				}
			}
		}
		2.配置nginx{
			1.打开/etc/nginx/nginx.conf文件{
				在http节点中添加节点：
				server{
					listen 80; #服务器的对外开放端口
					server_name localhost; #localhost本机，或者也可以写自己的网站的域名www.fucaijin.cn
					charset utf-8;
					#index index.nginx-debian.html ;
					#root /var/www/html;
					access_log off;
					location /static {
						alias /var/www/; 
					}
					location / {
						uwsgi_pass  127.0.0.1:8000; #要和uwsgi.ini中的socket一样
						include     /etc/nginx/uwsgi_params;
					}
				}
				
				网络简洁版{
					server {
						listen 80;
						server_name nocmt.com;

						location  /favicon.ico { 
							access_log off; 
							log_not_found off; 
						}
						
						location /static/ {
							root /home/nocmt;
						}

						location / {
							include         uwsgi_params; 
							uwsgi_pass      unix:/home/nocmt/nocmt.sock; #nocmt是网络教程作者的django项目名称
						}
					}
				}
				
				开启日志版{
					server{
						listen 80;
						server_name
						nocmt.com;
						access_log /home/nocmt/nginx.access.log;
						error_log /home/nocmt/nginx.error.log;

						location /static/ {
							root /home/nocmt;
						}
							
						location /favico.ico {
							root /home/nocmt/static/img/favico.ico;
						}
						
						location / {
							include uwsgi_params;
							uwsgi_pass unix: / home / nocmt / nocmt.sock;
						}
					}
				}
			}
		
		}
		
		3.测试nginx的配置，如果有错那就是配置错误：sudo service nginx configtest
		4.如果配置没错误，就重启nginx： sudo service nginx restart
		5.启动uwsgi，先进入uwsgi.ini文件的目录下，执行：uwsgi uwsgi.ini
	}
}

scrapy{
	 中文乱码：在setting文件中设置：FEED_EXPORT_ENCODING = 'utf-8' 即可
}

字符串{
	字符串拼接{
		
		1. 使用 + 拼接(低效) / 字符串和数字拼接："step="+str(1)
		
		2. 使用str.join(str)拼接(高效)
			','.join(pieces)
			'a,b,c,d,e'
	}
	
	'a' in 'abca' // 检查str是否在另一个str中，返回True或False
	
	字符串索引
	s.index('c') // 未找到时，返回ValueError
	s.find('c') // 未找到时，返回-1
	
	s.count(' ') //统计str1在str2中出现的次数
	
	str1.replace(str2,str3) // 将str1中所有的str2替换为str3,如：'a ,b , c, d, e'.replace(' ','') # 删除所有空格
	str1.replace(str2, str3,  mystr.count(str1))//把 str1 中的 str2 替换成 str3,如果 count 指定，则替换不超过 count 次
	
	字符串常见函数操作
	如有字符串mystr = 'hello world and bjsxt yunshuxueyuan sxt beijing'，以下是常见的操作

	<1>find
	mystr.find(str, start=0, end=len(mystr)) //检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则返回-1


	<2>index
	mystr.index(str, start=0, end=len(mystr)) //跟find()方法一样，只不过如果str不在 mystr中会报一个异常.


	<3>count
	mystr.count(str, start=0, end=len(mystr))  //返回 str在start和end之间 在 mystr里面出现的次数


	<4>replace
	mystr.replace(str1, str2,  mystr.count(str1))  //把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次.


	<5>split
	mystr.split(str=" ", 2)    //以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串


	<6>capitalize
	mystr.capitalize()  //把字符串的第一个字符大写


	<7>title
	mystr.title() //把字符串的每个单词首字母大写

	<8>startswith
	mystr.startswith(str) // 检查字符串是否是以str/某个字符串开头, 是则返回 True，否则返回 False


	<9>endswith
	mystr.endswith(obj)  // 检查字符串是否是以str/某个字符串结束, 是则返回 True，否则返回 False


	<10>lower
	mystr.lower()        // 转换 mystr 中所有大写字符为小写


	<11>upper
	mystr.upper()    //转换 mystr 中的小写字母为大写


	<12>ljust
	mystr.ljust(width) //返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串


	<13>rjust
	mystr.rjust(width)    //返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串


	<14>center
	mystr.center(width)   //返回一个原字符串居中,并使用空格填充至长度 width 的新字符串


	<15>lstrip
	mystr.lstrip()   //删除 mystr 左边的空白字符


	<16>rstrip
	mystr.rstrip()    //删除 mystr 字符串末尾的空白字符


	<17>strip
	mystr.strip()//删除mystr字符串两端的空白字符
	判断字符串是否为空： str.strip() == ""

	<18>rfind
	mystr.rfind(str, start=0,end=len(mystr) )//类似于 find()函数，不过是从右边开始查找.


	<19>rindex
	mystr.rindex( str, start=0,end=len(mystr))//类似于 index()，不过是从右边开始.


	<20>partition
	mystr.partition(str)//把mystr以str分割成三部分,str前，str和str后


	<21>rpartition
	mystr.rpartition(str)//类似于 partition()函数,不过是从右边开始.


	<22>splitlines
	mystr.splitlines()  //按照换行符分隔，返回一个包含各行作为元素的列表


	<23>isalpha
	mystr.isalpha()  //如果 mystr 所有字符都是字母 则返回 True,否则返回 False


	<24>isdigit
	mystr.isdigit() //如果 mystr 只包含数字则返回 True 否则返回 False.


	<25>isalnum
	mystr.isalnum()  //如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False


	<26>isspace
	mystr.isspace()   //如果 mystr 中只包含空格，则返回 True，否则返回 False.


	<27>join
	mystr.join(list) //mystr 中每个字符后面插入list的每个元素后面,构造出一个新的字符串。如："1".join("2") → "21"


	总结：

		查找字符串：

			find：找不到返回-1   ，都是从左边找，右边查找r

			index：找不到报错
	
	
} 

列表/元组/集合/字典{
	
	1. 列表list(如：booklist = ['Python','Java','PHP']){
		列表是一种用于保存一系列有序项目的集合。可重复，类型可不同。用“[]”表示。
		类似于栈，项目的列表用方括号括起来，创建的列表，可以添加、移除、搜索列表中的项目。
		既然可以添加或删除项目，列表是一种可变的（Mutable）数据类型。
		
		1. 可以用list()函数或者方括号[]创建，元素之间用逗号’,‘’分隔。 
		2. 列表的元素不需要具有相同的类型 
		3. 使用索引来访问元素 
		4. 可切片
		
		# 可用list()函数建立
		list1 = list((1, 2))
		# 用[]建立，可包含不同数据类型
		list2 = [1, 3, 'hello', 3.5]
		　　
		booklist = ['Python','Java','PHP']

		列表操作：
		booklist.append('Python Crash Course')//向列表尾部添加一个对象

		insert() :在任何位置添加新元素
		booklist.insert(0,'Mysql')    # 在列表开头添加新元素

		del语句：删除指定位置的元素
		del L[1]        #删除指定下标的元素
		del L[1:3]      #删除指定下标范围的元素

		#复制list:
		L1 = L      #L1为L的别名，用C来说就是指针地址相同，对L1操作即对L操作。
		L1 = L[:]   #L1为L的克隆，即另一个拷贝。

		pop():  默认删除末尾的元素，也可根据索引指定删除，删除后，可接着使用它的值
		new_booklist = booklist.pop()
		deleted_value = booklist.pop(2)     # 指定删除索引为2的元素, 接收被删除的值

		remove(): 根据元素的值删除
		booklist.remove('Mysql')         # 删除列表中值为“Mysql”的元素

		sort(): 对列表进行永久性排序
		booklist.sort()                    # 按照字母排序，排序后无法恢复
		booklist.sort(reverse=True)        # 字母反序排序

		sorted(): 临时排序，不影响原始排序
		booklist.sorted()                    # 按照字母排序，排序后无法恢复
		booklist.sorted(reverse=True)        # 字母反序排序

		reverse(): 反转列表元素的排序
		booklist.reverse()                # 永久性修改，但可再次调用reverse()恢复
		
		list.append():	追加成员
		list.count(x):	计算列表中参数x出现的次数
		list.extend(L):	向列表中追加另一个列表L
		list.index(x):	获得参数x在列表中的位置
		list.insert():	向列表中插入数据
		list.pop():	删除列表中的成员（通过下标删除）
		list.remove():	删除列表中的成员（直接删除）
		list.reverse():	将列表中成员的顺序颠倒
		list.sort():	将列表中成员排序
		
	}

	2. 元组tuple(如：booklist = ('Python','Java','PHP')){
		元组只读的,类似于列表，也可以存不同类型数据，不能修改,用“()”表示,使用逗号进行分隔。
		
		1. 可以用tuple()函数或者方括号()创建，元素之间用逗号’,‘’分隔。 
		2. 元组的元素不需要具有相同的类型 
		3. 使用索引来访问元素 
		4. 可切片 
		5. 元素的值一旦创建就不可修改!!!!!(这是区别与列表的一个特征）
		
		zoo = ('monkey','elephant',123)
		print zoo[1]
		
		cmp(tuple1, tuple2)	比较两个元组元素。
		len(tuple)			计算元组元素个数。
		max(tuple)			返回元组中元素最大值。
		min(tuple)			返回元组中元素最小值。
		tuple(seq)			将列表转换为元组。
		
		1. 当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来； 
		2. 定义只有一个元素的Tuple的时候，需要这样: 
		tuple1 = (123,) 
		后面要加上一个逗号，这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义。 
		tuple2 = (123) ＃如果你这样定义你定义的将是１２３这个元素，而不是一个元组。 
		
		元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组。
		元组的内置函数： 
		1. 比较两个元组元素：cmp(tuple1,tuple2)相等的话返回0，不相等返回1； 
		2. 计算元组的长度：len(tuple 
		3. 返回元组中的最大值最小值：max(tuple),min(tuple)； 
		4. 将列表转换成元组：Tuple = tuple(list)。
	}

	3. 字典dict(如：dict = {key1: value1, key2: values2}){
		键值对存储数据，键必须是唯一的，形式：键:值，全部由{}括起。字典中的数据是乱序的
		a_dict = {key1: value1, key2: values2}
		
		1. 元素由键（key）和值（value）组成 
		2. 可以用dict()函数或者方括号()创建，元素之间用逗号’,‘’分隔，键与值之间用冒号”:”隔开 
		3. 键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组 
		4. 使用键（key）来访问元素
		
		adict.keys()	返回一个包含字典所有KEY的列表；
		adict.values()	返回一个包含字典所有value的列表；
		adict.items()	返回一个包含所有（键，值）元祖的列表；
		adict.clear()	删除字典中的所有项或元素；
		adict.copy()	返回一个字典浅拷贝的副本；
		adict.fromkeys(seq, val=None)	创建并返回一个新字典，以seq中的元素做该字典的键，val做该字典中所有键对应的初始值（默认为None）；
		adict.get(key, default = None)	返回字典中key对应的值，若key不存在字典中，则返回default的值（default默认为None）；
		adict.has_key(key)	如果key在字典中，返回True，否则返回False。 现在用 in 、 not in；
		adict.iteritems() adict.iterkeys() adict.itervalues()	与它们对应的非迭代方法一样，不同的是它们返回一个迭代子，而不是一个列表；
		adict.pop(key[,default])	和get方法相似。如果字典中存在key，删除并返回key对应的vuale；如果key不存在，且没有给出default的值，则引发keyerror异常；
		adict.setdefault(key, default=None)	和set()方法相似，但如果字典中不存在Key键，由 adict[key] = default 为它赋值；
		adict.update(bdict)	将字典bdict的键值对添加到字典adict中。
		
		删除键值对：del
		del a_dict['key1']
		
		#更新成员，当对应键值不存在时，相当于加入  
		m.update({'d':4})  
	}

	4. 集合set(如：set(['Russia','India','China'])){
		集合最好的应用是去重。集合没有特殊的表示方法，而是通过一个set函数转换成集合，如：
		lst = [ 1, 1, 0]
		lst_set = set( lst )  #lst_set 为1 , 0
		或者：
		countries = set(['Russia','India','China'])
		
		具有以下特点： 
		1. 可以用set()函数或者方括号{}创建，元素之间用逗号”,”分隔。 
		2. 与字典相比少了键 
		3. 不可索引，不可切片 
		4. 不可以有重复元素
		
		s.issubset(t)，s <= t			测试是否 s 中的每一个元素都在 t 中
		s.issuperset(t)，s >= t			测试是否 t 中的每一个元素都在 s 中
		s.union(t)，s | t				返回一个新的 set 包含 s 和 t 中的每一个元素
		s.intersection(t)，s & t		返回一个新的 set 包含 s 和 t 中的公共元素
		s.difference(t),s - t			返回一个新的 set 包含 s 中有但是 t 中没有的元素
		s.symmetric_difference(t),s ^ t	返回一个新的 set 包含 s 和 t 中不重复的元素
		s.copy()						返回 set “s”的一个浅复制

		tup = (2, 2, 1)
		tup_set = set( tup) # tup_set为2 , 1

		for item in lst_set:
		print item
	}
}


图片和base64字符串之间的互换{
	
	将传过来的base64字符串，还原成图片保存{
		imgdata=base64.b64decode(strs)  
		file=open('1.jpg','wb') //在此处填写要保存的路径，和要保存的文件名，第二个参数不用管 
		file.write(imgdata)  
		file.close()
	}

	将图片转换成base64字符串{
		import base64
		f=open(r'c:\jb51.gif','rb') #二进制方式打开图文件
		ls_f=base64.b64encode(f.read()) #读取文件内容，转换为base64编码
		f.close()
	}
  
}

在for循环中拿到索引index{
	方法1：
		l = [2,7,11,15]
		for i in range(len(l)):
			print i,l[i]// i就是索引，l[i]就是遍历的元素
			
	方法2：
		l = [2,7,11,15]
		for index,value in enumerate(l):
		print index,value
			
}


































